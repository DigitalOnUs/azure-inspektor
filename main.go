package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"
	"unicode"

	"github.com/hashicorp/terraform/configs/configschema"
	tf "github.com/hashicorp/terraform/terraform"
	"github.com/stoewer/go-strcase"
	ms "github.com/terraform-providers/terraform-provider-azurerm/azurerm"
	"github.com/zclconf/go-cty/cty"
)

func main() {

	if len(os.Args) != 2 {
		fmt.Println("usage %s <output dir>", os.Args[0])
		os.Exit(1)
	}

	provider := ms.Provider()
	resources := provider.Resources()

	fmt.Printf("Total resources %d\n", len(resources))

	// checking if we can get the schema
	if len(resources) < 1 {
		fmt.Println("No resources available")
		os.Exit(1)
	}

	resourceTypes := make([]string, len(resources))

	for i, r := range resources {
		resourceTypes[i] = r.Name
	}

	request := tf.ProviderSchemaRequest{
		ResourceTypes: resourceTypes,
	}

	schema, err := provider.GetSchema(&request)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	var waitgroup sync.WaitGroup

	now := time.Now()

	for name, spec := range schema.ResourceTypes {
		r := templateInput{
			Timestamp:  now,
			Name:       name,
			Attributes: spec.Attributes,
			Blocks:     spec.BlockTypes,
		}

		waitgroup.Add(1)

		go func() {
			defer waitgroup.Done()
			outputPath := filepath.Join(os.Args[1], r.Name+".go")
			file, err := os.Create(outputPath)
			if err != nil {
				// abort everything
				log.Fatalf("%s", err)
			}

			defer file.Close()
			templateFile.Execute(file, r)

		}()

		//	fmt.Printf("* %s      : %s \n", nested, desc.Nesting.String())

	}

	waitgroup.Wait()
	log.Println("looks like all done")
}

type templateInput struct {
	Timestamp  time.Time
	Name       string
	Attributes map[string]*configschema.Attribute
	Blocks     map[string]*configschema.NestedBlock
}

var structsFuncMap = template.FuncMap{
	"getTick": func() string {
		return "`"
	},
	"camelCase": func(in string) string {
		return strcase.UpperCamelCase(in)
	},
	// azure is camel case except the first letter
	"lowerFirst": func(in string) string {
		camel := strcase.UpperCamelCase(in)
		if len(camel) > 1 {
			for i, v := range camel {
				return string(unicode.ToLower(v)) + camel[i+1:]
			}
		}
		return in
	},
	"getCTYType": func(t cty.Type) string {
		return t.GoString()
	},
	"nestingType": func(t *configschema.NestedBlock) string {
		return t.Nesting.String()
	},
}

var templateFile = template.Must(template.New("").Funcs(structsFuncMap).Parse(`// This file was generated by DoU robots 
// at {{ .Timestamp }}
// based on the terraform schema
package armtf
{{ $CamelName := camelCase .Name}}

type {{ $CamelName }} struct {
// standalone requirements
{{- range $k, $v := .Attributes }}
	{{ camelCase $k }} interface{} {{ getTick }}json:"{{ lowerFirst $k }},omitempty" hcl:"{{ $k }},{{ getCTYType $v.Type }}"{{ getTick }} 
{{- end }}
// blocks 
{{- range $k, $v := .Blocks }}
	{{ camelCase $k }} interface{} {{ getTick }}json:"{{ lowerFirst $k }},omitempty" hcl:"{{ $k }},{{ nestingType $v }}"{{ getTick }} 
{{- end }}

}

func (r *{{ $CamelName }}) TerraformType () string {
	return "{{ .Name }}"
}

//Required attributes expected name in json
func (r *{{ $CamelName }}) Required () []string {
	return []string{ 
	{{- range $k, $v := .Attributes }} {{ if $v.Required }} "{{ lowerFirst $k }}",{{ end }} {{- end }}
	}
}

//Computed attributes (this ones come from the state and are optionals)
func (r *{{ $CamelName }}) Computed () []string {
	return []string{ 
	{{- range $k, $v := .Attributes }}{{ if $v.Computed }} "{{ lowerFirst $k }}",{{ end }} {{- end }}
	}
}

`))
