package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"
	"unicode"

	"github.com/hashicorp/terraform/configs/configschema"
	tf "github.com/hashicorp/terraform/terraform"
	"github.com/stoewer/go-strcase"
	ms "github.com/terraform-providers/terraform-provider-azurerm/azurerm"
	"github.com/zclconf/go-cty/cty"
)

func main() {

	if len(os.Args) != 2 {
		fmt.Println("usage %s <output dir>", os.Args[0])
		os.Exit(1)
	}

	provider := ms.Provider()
	resources := provider.Resources()

	fmt.Printf("Total resources %d\n", len(resources))

	// checking if we can get the schema
	if len(resources) < 1 {
		fmt.Println("No resources available")
		os.Exit(1)
	}

	resourceTypes := make([]string, len(resources))

	for i, r := range resources {
		resourceTypes[i] = r.Name
	}

	request := tf.ProviderSchemaRequest{
		ResourceTypes: resourceTypes,
	}

	schema, err := provider.GetSchema(&request)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	var waitgroup sync.WaitGroup

	now := time.Now()

	for name, spec := range schema.ResourceTypes {
		r := templateInput{
			Timestamp:  now,
			Name:       name,
			Attributes: spec.Attributes,
			Blocks:     spec.BlockTypes,
		}

		waitgroup.Add(1)

		go func() {
			defer waitgroup.Done()
			outputPath := filepath.Join(os.Args[1], r.Name+".go")
			file, err := os.Create(outputPath)
			if err != nil {
				// abort everything
				log.Fatalf("%s", err)
			}

			defer file.Close()
			templateFile.Execute(file, r)

		}()

	}

	waitgroup.Wait()
	log.Println("looks like all done")
}

type templateInput struct {
	Timestamp  time.Time
	Name       string
	Attributes map[string]*configschema.Attribute
	Blocks     map[string]*configschema.NestedBlock
}

var structsFuncMap = template.FuncMap{
	"getTick": func() string {
		return "`"
	},
	"camelCase": func(in string) string {
		return strcase.UpperCamelCase(in)
	},
	// azure is camel case except the first letter
	"lowerFirst": func(in string) string {
		camel := strcase.UpperCamelCase(in)
		if len(camel) > 1 {
			for i, v := range camel {
				return string(unicode.ToLower(v)) + camel[i+1:]
			}
		}
		return in
	},
	"getCTYType": func(t cty.Type) string {
		return t.GoString()
	},
	"nestingType": func(t *configschema.NestedBlock) string {
		return t.Nesting.String()
	},
}

var templateFile = template.Must(template.New("").Funcs(structsFuncMap).Parse(`// This file was generated by DoU robots
// at {{ .Timestamp }}
// based on the terraform schema
package hcl

import(
	"errors"
	"strings"
	"github.com/leofigy/structs"
	"github.com/iancoleman/strcase"
)

{{ $CamelName := camelCase .Name}}

type {{ $CamelName }} struct {
// standalone requirements
{{- range $k, $v := .Attributes }}
	{{ camelCase $k }} interface{} {{ getTick }}json:"{{ lowerFirst $k }},omitempty" hcl:"{{ $k }},{{ getCTYType $v.Type }}"{{ getTick }}
{{- end }}
// blocks
{{- range $k, $v := .Blocks }}
	{{ camelCase $k }} interface{} {{ getTick }}json:"{{ lowerFirst $k }},omitempty" hcl:"{{ $k }},{{ nestingType $v }}"{{ getTick }}
{{- end }}

}

// special case now for nested block in case they have some attribute we want to filter (not the best)
func (r *{{ $CamelName }}) SchemaBlocks() (map[string]map[string]struct{}) {
	return map[string]map[string]struct{}{
		{{- range $k, $v := .Blocks }}
			"{{ $k}}" : map[string]struct{}{
				{{- range $ik, $v  := $v.Block.Attributes }}
					"{{ $ik }}" : struct{}{},
				{{- end }}
			},
		{{- end }}
	}
}


func (r *{{ $CamelName }}) TerraformType () string {
	return "{{ .Name }}"
}

//Required attributes expected name in json
func (r *{{ $CamelName }}) Required () []string {
	return []string{
	{{- range $k, $v := .Attributes }} {{ if $v.Required }} "{{ lowerFirst $k }}",{{ end }} {{- end }}
	}
}

//Computed attributes (this ones come from the state and are optionals)
func (r *{{ $CamelName }}) Computed () []string {
	return []string{
	{{- range $k, $v := .Attributes }}{{ if $v.Computed }} "{{ lowerFirst $k }}",{{ end }} {{- end }}
	}
}

//Translate to terraform names
func (r *{{ $CamelName }}) Terraform () (out map[string]interface{},err error) {
	out = make(map[string]interface{})
	// Unmarshal a bit hacky but just temporary
	fields := structs.Fields(r)
	// blocks
	schemaBlocks := r.SchemaBlocks()

	for _, e := range fields{

		// by now we don't care if is non zero
		// upper layer will take a look to that

		hclTag := e.Tag("hcl")
		// meanwhile just translate to the other name
		// (nothing to do yet with the cty type)
		tag := strings.SplitN(hclTag, ",", 2)
		// this error should never happen if this is the case
		// then somebody modified this autogen file
		if len(tag) != 2 {
			err = errors.New("spurious struct tag @" + r.TerraformType())
			return
		}
		// Note the second attribute will be later updated
		name := tag[0]
		out[name] = e.Value()
		// check for blocks
		if len(schemaBlocks) > 0 {
			if hclProps, ok := schemaBlocks[name]; ok {
				// check if we can convert the interface into a map
				cleaner := func(in map[string]interface{}) map[string]interface{}{
						for inputAttribute := range in{
							if _, ok := hclProps[strcase.ToSnake(inputAttribute)]; !ok {
								delete(in, inputAttribute)
							}
						}
					return in
				}

				data := out[name]
				// nested blocks can be anything like [] arrays + raw object so let's do this
				switch block := data.(type) {
					case []interface{}:
						for i, value := range block {
							listItem, ok := value.(map[string]interface{})
							if ok {
								block[i] = cleaner(listItem)
							}
						}
						out[name] = block

					case map[string]interface{}:
						out[name] = cleaner(block)
				}
			}
		}
	}
	return
}
`))
